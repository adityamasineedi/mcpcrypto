const { Telegraf, Markup } = require('telegraf');
const config = require('./config');
const logger = require('./utils/logger');

class TelegramBot {
  constructor() {
    this.bot = null;
    this.initialized = false;
    this.messageQueue = [];
    this.rateLimitQueue = [];
    this.lastMessageTime = 0;
    this.minMessageInterval = 2000; // 2 seconds between messages
  }

  /**
   * üöÄ Initialize Telegram Bot
   */
  async init() {
    try {
      if (!config.telegram.enabled || !config.telegram.botToken) {
        logger.warn('‚ö†Ô∏è Telegram bot disabled or token missing');
        this.initialized = true; // Mark as initialized but inactive
        return;
      }

      this.bot = new Telegraf(config.telegram.botToken);
      
      // Set up bot commands
      this.setupCommands();
      
      // Test bot connection
      const botInfo = await this.bot.telegram.getMe();
      logger.info(`‚úÖ Telegram bot connected: @${botInfo.username}`);
      
      // Start bot
      if (!config.testMode) {
        this.bot.launch();
        logger.info('üöÄ Telegram bot launched');
      }
      
      this.initialized = true;
      
      // Send startup message
      await this.sendMessage('üöÄ ProTradeAI Bot is now online and ready to send signals!');
      
    } catch (error) {
      logger.error('‚ùå Telegram bot initialization failed:', error.message);
      this.initialized = true; // Continue without Telegram
    }
  }

  /**
   * ‚öôÔ∏è Setup bot commands
   */
  setupCommands() {
    if (!this.bot) return;

    // Start command
    this.bot.command('start', (ctx) => {
      ctx.reply(
        'ü§ñ Welcome to ProTradeAI Bot!\n\n' +
        'üìä I provide crypto trading signals with 75%+ win rate\n' +
        'üí∞ Target: $50+ daily profit\n' +
        'üéØ Features: AI analysis, technical indicators, risk management\n\n' +
        'Commands:\n' +
        '/status - Bot status\n' +
        '/stats - Trading statistics\n' +
        '/settings - Bot settings\n' +
        '/tpmode - TP calculation mode\n' +
        '/tpcalc - TP calculation details\n' +
        '/help - Show help'
      );
    });

    // Status command
    this.bot.command('status', async (ctx) => {
      const status = await this.getBotStatus();
      ctx.reply(status, { parse_mode: 'HTML' });
    });

    // Stats command
    this.bot.command('stats', async (ctx) => {
      const stats = await this.getTradingStats();
      ctx.reply(stats, { parse_mode: 'HTML' });
    });

    // Settings command
    this.bot.command('settings', (ctx) => {
      const settings = this.getSettingsInfo();
      ctx.reply(settings, { parse_mode: 'HTML' });
    });

    // Help command
    this.bot.command('help', (ctx) => {
      ctx.reply(
        'üìö <b>ProTradeAI Bot Help</b>\n\n' +
        'üîî <b>Notifications:</b>\n' +
        '‚Ä¢ Trading signals with entry/exit points\n' +
        '‚Ä¢ Trade execution confirmations\n' +
        '‚Ä¢ Daily P&L summaries\n' +
        '‚Ä¢ Error alerts\n\n' +
        'üìä <b>Signal Format:</b>\n' +
        '‚Ä¢ Coin symbol and direction (LONG/SHORT)\n' +
        '‚Ä¢ Confidence level (0-100%)\n' +
        '‚Ä¢ Entry price and targets\n' +
        '‚Ä¢ Risk level and position size\n' +
        '‚Ä¢ AI reasoning\n\n' +
        '‚öôÔ∏è <b>Commands:</b>\n' +
        '/start - Welcome message\n' +
        '/status - Current bot status\n' +
        '/stats - Trading performance\n' +
        '/settings - Configuration info\n' +
        '/tpmode - TP calculation mode\n' +
        '/tpcalc - TP calculation details\n' +
        '/help - This help message',
        { parse_mode: 'HTML' }
      );
    });

    // üöÄ NEW: TP Mode command
    this.bot.command('tpmode', (ctx) => {
      const isDynamicMode = process.env.DYNAMIC_TP_ENABLED !== 'false';
      const modeText = isDynamicMode ? 'Dynamic (Adaptive)' : 'Static (Percentage)';
      
      ctx.reply(
        `üéØ <b>Take Profit Mode Status</b>\n\n` +
        `Current Mode: <b>${modeText}</b>\n\n` +
        `üìä <b>Dynamic Mode Features:</b>\n` +
        `‚Ä¢ Volatility-based calculations\n` +
        `‚Ä¢ Support/Resistance levels\n` +
        `‚Ä¢ ATR-based adjustments\n` +
        `‚Ä¢ Market regime adaptation\n` +
        `‚Ä¢ Fibonacci retracements\n\n` +
        `üìà <b>Static Mode Features:</b>\n` +
        `‚Ä¢ Fixed percentage targets\n` +
        `‚Ä¢ Predictable levels\n` +
        `‚Ä¢ Simple calculations\n\n` +
        `Use /tpcalc to see calculation details`,
        { parse_mode: 'HTML' }
      );
    });

    // üöÄ NEW: TP Calculation Details command
    this.bot.command('tpcalc', (ctx) => {
      ctx.reply(
        `üî¨ <b>TP Calculation Methods</b>\n\n` +
        `üéØ <b>Dynamic Calculations:</b>\n` +
        `‚Ä¢ <b>Volatility:</b> Adjusts based on price movement\n` +
        `‚Ä¢ <b>ATR:</b> Uses Average True Range\n` +
        `‚Ä¢ <b>Support/Resistance:</b> Key price levels\n` +
        `‚Ä¢ <b>Fibonacci:</b> Golden ratio retracements\n` +
        `‚Ä¢ <b>Market Regime:</b> Bull/Bear/Sideways adaptation\n\n` +
        `üìä <b>Weighting System:</b>\n` +
        `‚Ä¢ Each method gets a confidence score\n` +
        `‚Ä¢ Higher confidence = more influence\n` +
        `‚Ä¢ Final TP = weighted average of all methods\n\n` +
        `üé™ <b>Static Fallback:</b>\n` +
        `‚Ä¢ TP1: ${config.trading.takeProfit1Percent}%\n` +
        `‚Ä¢ TP2: ${config.trading.takeProfit2Percent}%\n` +
        `‚Ä¢ TP3: ${config.trading.takeProfit3Percent}%`,
        { parse_mode: 'HTML' }
      );
    });

    // Error handling
    this.bot.catch((err, ctx) => {
      logger.error('Telegram bot error:', err);
    });
  }

  /**
   * üì® Send trading signal
   */
  async sendSignal(signal) {
    logger.debug(`üîç sendSignal called for ${signal.symbol}, initialized: ${this.initialized}, notifications.signals: ${config.telegram.notifications.signals}`);
    
    if (!this.initialized || !config.telegram.notifications.signals) {
      logger.debug(`‚ö†Ô∏è Skipping signal send - initialized: ${this.initialized}, notifications: ${config.telegram.notifications.signals}`);
      return;
    }

    try {
      const message = this.formatSignalMessage(signal);
      const keyboard = this.createSignalKeyboard(signal);
      
      logger.debug(`üì® Sending signal message for ${signal.symbol}...`);
      
      await this.sendMessage(message, { 
        parse_mode: 'HTML',
        reply_markup: keyboard
      });
      
      logger.info(`üì® Signal sent for ${signal.symbol}: ${signal.type}`);
    } catch (error) {
      logger.error('‚ùå Error sending signal:', error.message);
    }
  }

  /**
   * üéØ Format signal message
   */
  formatSignalMessage(signal) {
    const direction = signal.type === 'LONG' ? 'üü¢' : signal.type === 'SHORT' ? 'üî¥' : 'üü°';
    const risk = signal.risk === 'LOW' ? 'üü¢' : signal.risk === 'MEDIUM' ? 'üü°' : 'üî¥';
    const confidence = signal.finalConfidence;
    const confidenceEmoji = confidence >= 80 ? 'üî•' : confidence >= 70 ? '‚ö°' : confidence >= 60 ? '‚úÖ' : '‚ö†Ô∏è';

    let message = `${direction} <b>${signal.symbol} ${signal.type}</b> ${confidenceEmoji}\n\n`;
    
    // Signal details
    message += `üìä <b>Signal Details:</b>\n`;
    message += `‚Ä¢ Confidence: <b>${confidence}%</b>\n`;
    message += `‚Ä¢ Strength: <b>${signal.strength}</b>\n`;
    message += `‚Ä¢ Risk Level: ${risk} <b>${signal.risk}</b>\n`;
    
    // ‚úÖ ENHANCED: Specific hold duration
    const holdDuration = this.getHoldDuration(signal.timeHorizon, signal.strength, signal.context.regime);
    message += `‚Ä¢ Hold Duration: <b>${holdDuration}</b>\n`;
    message += `‚Ä¢ Strategy: <b>${this.getStrategyType(signal.context.regime, signal.timeHorizon)}</b>\n\n`;
    
    // Prices with Multiple Take Profit Levels
    message += `üí∞ <b>Price Levels:</b>\n`;
    message += `‚Ä¢ Current: <b>$${signal.currentPrice.toFixed(4)}</b>\n`;
    message += `‚Ä¢ Entry: <b>$${signal.entryPrice.toFixed(4)}</b>\n`;
    message += `‚Ä¢ Stop Loss: <b>$${signal.stopLoss.toFixed(4)}</b>\n\n`;
    
    // ‚úÖ NEW: Enhanced Multiple Take Profit Levels
    message += `üéØ <b>Take Profit Strategy:</b>\n`;
    const config = require('./config');
    const entryPrice = signal.entryPrice || signal.currentPrice;
    
    // üöÄ Use dynamic TPs if available, otherwise fallback to static
    let tp1Price, tp2Price, tp3Price, tpMethod, tpConfidence;
    
    if (signal.dynamicTPs) {
      // Use dynamic TP calculation
      tp1Price = signal.dynamicTPs.tp1.price;
      tp2Price = signal.dynamicTPs.tp2.price;
      tp3Price = signal.dynamicTPs.tp3.price;
      tpMethod = signal.dynamicTPs.method || 'adaptive';
      tpConfidence = signal.dynamicTPs.confidence;
      
      message += `üî• <b>Dynamic TPs (${tpMethod.toUpperCase()}):</b>\n`;
      message += `‚Ä¢ TP1 (${config.trading.tp1PositionPercent}%): <b>$${tp1Price.toFixed(4)}</b> (+${((tp1Price - entryPrice) / entryPrice * 100).toFixed(1)}%) üéØ\n`;
      message += `‚Ä¢ TP2 (${config.trading.tp2PositionPercent}%): <b>$${tp2Price.toFixed(4)}</b> (+${((tp2Price - entryPrice) / entryPrice * 100).toFixed(1)}%) ÔøΩ\n`;
      message += `‚Ä¢ TP3 (${config.trading.tp3PositionPercent}%): <b>$${tp3Price.toFixed(4)}</b> (+${((tp3Price - entryPrice) / entryPrice * 100).toFixed(1)}%) ÔøΩ\n`;
      
      if (tpConfidence) {
        message += `‚Ä¢ TP Confidence: <b>${tpConfidence.toFixed(1)}%</b> üî¨\n`;
      }
      
      // Show calculation methods used
      if (signal.dynamicTPs.calculations) {
        const methods = Object.keys(signal.dynamicTPs.calculations).join(', ');
        message += `‚Ä¢ Methods: <i>${methods}</i>\n`;
      }
    } else {
      // Fallback to static percentage-based TPs
      const calculateTP = (price, percent, type) => {
        return type === 'LONG' ? 
          price * (1 + percent / 100) : 
          price * (1 - percent / 100);
      };
      
      tp1Price = calculateTP(entryPrice, config.trading.takeProfit1Percent, signal.type);
      tp2Price = calculateTP(entryPrice, config.trading.takeProfit2Percent, signal.type);
      tp3Price = calculateTP(entryPrice, config.trading.takeProfit3Percent, signal.type);
      
      message += `üìä <b>Static TPs (Percentage-based):</b>\n`;
      message += `‚Ä¢ TP1 (${config.trading.tp1PositionPercent}%): <b>$${tp1Price.toFixed(4)}</b> (+${config.trading.takeProfit1Percent}%) üéØ\n`;
      message += `‚Ä¢ TP2 (${config.trading.tp2PositionPercent}%): <b>$${tp2Price.toFixed(4)}</b> (+${config.trading.takeProfit2Percent}%) üöÄ\n`;
      message += `‚Ä¢ TP3 (${config.trading.tp3PositionPercent}%): <b>$${tp3Price.toFixed(4)}</b> (+${config.trading.takeProfit3Percent}%) üíé\n`;
      message += `‚Ä¢ Mode: <i>Fixed percentage targets</i>\n`;
    }
    
    // Legacy TP for backwards compatibility
    if (signal.takeProfit) {
      message += `‚Ä¢ Full TP: <b>$${signal.takeProfit.toFixed(4)}</b> (Legacy)\n`;
    }
    message += '\n';
    
    // Position details
    message += `üìà <b>Position:</b>\n`;
    message += `‚Ä¢ Size: <b>$${signal.positionSize.toFixed(2)}</b>\n`;
    message += `‚Ä¢ Max Loss: <b>$${signal.maxLoss.toFixed(2)}</b>\n`;
    if (signal.maxGain) {
      message += `‚Ä¢ Max Gain: <b>$${signal.maxGain.toFixed(2)}</b>\n`;
    }
    if (signal.riskReward) {
      message += `‚Ä¢ Risk/Reward: <b>1:${signal.riskReward.toFixed(1)}</b>\n`;
    }
    message += '\n';

    // ‚úÖ NEW: Position Management
    message += `‚è∞ <b>Position Management:</b>\n`;
    const exitConditions = this.getExitConditions(signal);
    exitConditions.forEach(condition => {
      message += `‚Ä¢ ${condition}\n`;
    });
    message += '\n';
    
    // Market context
    message += `üåç <b>Market Context:</b>\n`;
    message += `‚Ä¢ Regime: <b>${signal.context.regime}</b>\n`;
    message += `‚Ä¢ Sentiment: <b>${signal.context.sentiment}</b>\n`;
    message += `‚Ä¢ Fear/Greed: <b>${signal.context.fearGreed}</b>\n\n`;
    
    // AI Analysis with all 3 models
    message += `ü§ñ <b>AI Analysis:</b>\n`;
    message += `‚Ä¢ GPT-4: <b>${signal.ai.sources.gpt.confidence}%</b> (${signal.ai.sources.gpt.recommendation})\n`;
    message += `‚Ä¢ Claude: <b>${signal.ai.sources.claude.confidence}%</b> (${signal.ai.sources.claude.recommendation})\n`;
    if (signal.ai.sources.gemini) {
      message += `‚Ä¢ Gemini: <b>${signal.ai.sources.gemini.confidence}%</b> (${signal.ai.sources.gemini.recommendation})\n`;
    }
    message += `‚Ä¢ Reasoning: <i>${signal.ai.reasoning}</i>\n\n`;
    
    // Technical analysis
    message += `üìä <b>Technical:</b>\n`;
    message += `‚Ä¢ Score: <b>${signal.technical.confidence}%</b>\n`;
    message += `‚Ä¢ Signals: <i>${signal.technical.reasoning}</i>\n\n`;
    
    message += `‚è∞ <i>${new Date(signal.timestamp).toLocaleString()}</i>`;
    
    return message;
  }

  /**
   * ‚úÖ NEW: Get specific hold duration
   */
  getHoldDuration(timeHorizon, strength, regime) {
    const durations = {
      SHORT: {
        WEAK: '15-30 min',
        MEDIUM: '30-60 min', 
        STRONG: '1-2 hours'
      },
      MEDIUM: {
        WEAK: '2-4 hours',
        MEDIUM: '4-8 hours',
        STRONG: '8-12 hours'
      },
      LONG: {
        WEAK: '12-24 hours',
        MEDIUM: '1-2 days',
        STRONG: '2-3 days'
      }
    };

    // Adjust for market regime
    let baseDuration = durations[timeHorizon]?.[strength] || '1-2 hours';
    
    if (regime === 'SIDEWAYS') {
      baseDuration = baseDuration.replace(/hours/g, 'hours (shorter in sideways market)');
    }
    
    return baseDuration;
  }

  /**
   * ‚úÖ NEW: Get strategy type
   */
  getStrategyType(regime, timeHorizon) {
    if (regime === 'BULL' && timeHorizon === 'SHORT') return 'Momentum Scalping';
    if (regime === 'BULL' && timeHorizon === 'MEDIUM') return 'Trend Following';
    if (regime === 'BULL' && timeHorizon === 'LONG') return 'Position Trading';
    if (regime === 'BEAR' && timeHorizon === 'SHORT') return 'Bounce Trading';
    if (regime === 'BEAR') return 'Reversal Strategy';
    if (regime === 'SIDEWAYS') return 'Range Trading';
    return 'Adaptive Strategy';
  }

  /**
   * ‚úÖ NEW: Get exit conditions
   */
  getExitConditions(signal) {
    const conditions = [];
    
    // Time-based exits
    const holdDuration = this.getHoldDuration(signal.timeHorizon, signal.strength, signal.context.regime);
    conditions.push(`‚è±Ô∏è Close after: <b>${holdDuration}</b>`);
    
    // Price-based exits
    conditions.push(`üéØ Take Profit: <b>$${signal.takeProfit?.toFixed(4) || 'Manual'}</b>`);
    conditions.push(`üõë Stop Loss: <b>$${signal.stopLoss.toFixed(4)}</b>`);
    
    // Condition-based exits
    if (signal.context.regime === 'SIDEWAYS') {
      conditions.push(`üìä Exit if: Range breakout confirmed`);
    } else if (signal.context.regime === 'BULL') {
      conditions.push(`üìà Trail stop: Move SL to breakeven at +50%`);
    } else if (signal.context.regime === 'BEAR') {
      conditions.push(`üìâ Quick exit: Close on volume spike reversal`);
    }
    
    // Technical exit signals
    if (signal.strength === 'STRONG') {
      conditions.push(`üîÑ Monitor: RSI divergence for early exit`);
    }
    
    return conditions;
  }

  /**
   * ‚å®Ô∏è Create signal keyboard
   */
  createSignalKeyboard(signal) {
    if (!config.telegram.signalApproval) return null;

    return Markup.inlineKeyboard([
      [
        Markup.button.callback('‚úÖ Execute', `execute_${signal.id}`),
        Markup.button.callback('‚ùå Reject', `reject_${signal.id}`)
      ],
      [
        Markup.button.callback('üìä Details', `details_${signal.id}`),
        Markup.button.callback('‚è∞ Delay', `delay_${signal.id}`)
      ]
    ]);
  }

  /**
   * üíº Send trade execution notification
   */
  async sendTradeExecution(trade) {
    if (!this.initialized || !config.telegram.notifications.trades) return;

    try {
      const direction = trade.side === 'LONG' ? 'üü¢' : 'üî¥';
      const status = trade.status === 'FILLED' ? '‚úÖ' : trade.status === 'FAILED' ? '‚ùå' : '‚è≥';
      
      let message = `${status} <b>Trade ${trade.status}</b> ${direction}\n\n`;
      
      message += `ü™ô <b>Symbol:</b> ${trade.symbol}\n`;
      message += `üìä <b>Side:</b> ${trade.side}\n`;
      message += `üí∞ <b>Size:</b> $${trade.amount.toFixed(2)}\n`;
      message += `üíµ <b>Price:</b> $${trade.price.toFixed(4)}\n`;
      
      if (trade.status === 'FILLED') {
        message += `üî• <b>Total:</b> $${(trade.amount * trade.price).toFixed(2)}\n`;
        if (trade.fee) {
          message += `üí∏ <b>Fee:</b> $${trade.fee.toFixed(2)}\n`;
        }
      }
      
      if (trade.error) {
        message += `‚ùå <b>Error:</b> ${trade.error}\n`;
      }
      
      message += `\n‚è∞ ${new Date(trade.timestamp).toLocaleString()}`;
      
      await this.sendMessage(message, { parse_mode: 'HTML' });
      
      logger.info(`üì® Trade notification sent: ${trade.symbol} ${trade.status}`);
    } catch (error) {
      logger.error('‚ùå Error sending trade notification:', error.message);
    }
  }

  /**
   * üéØ Send Take Profit notification
   */
  async sendTPNotification(trade, level, profit) {
    if (!this.initialized || !config.telegram.notifications.trades) {
      return;
    }

    try {
      const tpEmojis = {
        'TP1': 'üéØ',
        'TP2': 'üöÄ', 
        'TP3': 'üíé'
      };
      
      const emoji = tpEmojis[level] || 'üéØ';
      const profitEmoji = profit > 0 ? 'üí∞' : 'üí∏';
      
      let message = `${emoji} <b>${level} HIT!</b> ${profitEmoji}\n\n`;
      
      message += `üìä <b>Trade Details:</b>\n`;
      message += `‚Ä¢ Symbol: <b>${trade.symbol} ${trade.type}</b>\n`;
      message += `‚Ä¢ Level: <b>${level}</b>\n`;
      message += `‚Ä¢ Profit: <b>${profit > 0 ? '+' : ''}$${profit.toFixed(2)}</b>\n`;
      message += `‚Ä¢ Remaining: <b>${trade.remainingQuantity.toFixed(4)}</b>\n\n`;
      
      message += `üíº <b>Position Status:</b>\n`;
      message += `‚Ä¢ Total P&L: <b>$${trade.realizedPnL.toFixed(2)}</b>\n`;
      message += `‚Ä¢ Status: <b>${trade.status}</b>\n`;
      
      if (trade.remainingQuantity > 0) {
        const nextTP = level === 'TP1' ? 'TP2' : level === 'TP2' ? 'TP3' : 'None';
        if (nextTP !== 'None') {
          message += `‚Ä¢ Next Target: <b>${nextTP}</b>\n`;
        }
        
        if (trade.stopLoss.trailing) {
          message += `‚Ä¢ Trailing Stop: <b>$${trade.stopLoss.price.toFixed(4)}</b>\n`;
        }
      } else {
        message += `‚Ä¢ <b>Position Fully Closed!</b> üéâ\n`;
      }
      
      message += `\n‚è∞ <i>${new Date().toLocaleString()}</i>`;
      
      await this.sendMessage(message, { parse_mode: 'HTML' });
      
      logger.info(`üì® ${level} notification sent for ${trade.symbol}: +$${profit.toFixed(2)}`);
    } catch (error) {
      logger.error(`‚ùå Error sending ${level} notification:`, error.message);
    }
  }

  /**
   * üõë Send Stop Loss notification
   */
  async sendStopLossNotification(trade, loss) {
    if (!this.initialized || !config.telegram.notifications.trades) {
      return;
    }

    try {
      let message = `üõë <b>STOP LOSS HIT</b> üí∏\n\n`;
      
      message += `üìä <b>Trade Details:</b>\n`;
      message += `‚Ä¢ Symbol: <b>${trade.symbol} ${trade.type}</b>\n`;
      message += `‚Ä¢ Loss: <b>$${loss.toFixed(2)}</b>\n`;
      message += `‚Ä¢ Entry: <b>$${trade.entryPrice.toFixed(4)}</b>\n`;
      message += `‚Ä¢ Exit: <b>$${trade.stopLoss.price.toFixed(4)}</b>\n\n`;
      
      message += `üíº <b>Final Position:</b>\n`;
      message += `‚Ä¢ Total P&L: <b>$${trade.realizedPnL.toFixed(2)}</b>\n`;
      message += `‚Ä¢ Status: <b>STOPPED</b>\n`;
      
      // Show any partial profits taken
      const { tp1, tp2, tp3 } = trade.takeProfits;
      let partialProfits = 0;
      if (tp1.executed) partialProfits += 1;
      if (tp2.executed) partialProfits += 1;
      if (tp3.executed) partialProfits += 1;
      
      if (partialProfits > 0) {
        message += `‚Ä¢ TPs Hit: <b>${partialProfits}/3</b> ‚úÖ\n`;
        message += `‚Ä¢ <i>Some profit was secured before stop loss</i>\n`;
      }
      
      message += `\n‚è∞ <i>${new Date().toLocaleString()}</i>`;
      
      await this.sendMessage(message, { parse_mode: 'HTML' });
      
      logger.warn(`üì® Stop loss notification sent for ${trade.symbol}: $${loss.toFixed(2)}`);
    } catch (error) {
      logger.error('‚ùå Error sending stop loss notification:', error.message);
    }
  }

  /**
   * üìà Send trailing stop update notification
   */
  async sendTrailingStopUpdate(trade, oldPrice, newPrice) {
    if (!this.initialized || !config.telegram.notifications.trades) {
      return;
    }

    try {
      // Only send periodic updates, not every small change
      const priceChange = Math.abs(newPrice - oldPrice);
      const percentChange = (priceChange / oldPrice) * 100;
      
      // Only notify for significant moves (0.5%+)
      if (percentChange < 0.5) {
        return;
      }
      
      let message = `üìà <b>Trailing Stop Updated</b>\n\n`;
      
      message += `üìä <b>Trade Details:</b>\n`;
      message += `‚Ä¢ Symbol: <b>${trade.symbol} ${trade.type}</b>\n`;
      message += `‚Ä¢ Old Stop: <b>$${oldPrice.toFixed(4)}</b>\n`;
      message += `‚Ä¢ New Stop: <b>$${newPrice.toFixed(4)}</b>\n`;
      message += `‚Ä¢ Protection: <b>+${((newPrice - trade.entryPrice) / trade.entryPrice * 100).toFixed(2)}%</b>\n\n`;
      
      message += `üíº <b>Position Status:</b>\n`;
      message += `‚Ä¢ Remaining: <b>${trade.remainingQuantity.toFixed(4)}</b>\n`;
      message += `‚Ä¢ Unrealized P&L: <b>$${trade.unrealizedPnL.toFixed(2)}</b>\n`;
      
      message += `\n‚è∞ <i>${new Date().toLocaleString()}</i>`;
      
      await this.sendMessage(message, { parse_mode: 'HTML' });
      
      logger.info(`üì® Trailing stop notification sent for ${trade.symbol}`);
    } catch (error) {
      logger.error('‚ùå Error sending trailing stop notification:', error.message);
    }
  }

  /**
   * üéâ Send trade completion summary
   */
  async sendTradeCompletionSummary(trade) {
    if (!this.initialized || !config.telegram.notifications.trades) {
      return;
    }

    try {
      const isProfit = trade.realizedPnL > 0;
      const emoji = isProfit ? 'üéâ' : 'üòû';
      const statusEmoji = isProfit ? 'üí∞' : 'üí∏';
      
      let message = `${emoji} <b>TRADE COMPLETED</b> ${statusEmoji}\n\n`;
      
      message += `üìä <b>Trade Summary:</b>\n`;
      message += `‚Ä¢ Symbol: <b>${trade.symbol} ${trade.type}</b>\n`;
      message += `‚Ä¢ Entry: <b>$${trade.entryPrice.toFixed(4)}</b>\n`;
      message += `‚Ä¢ Duration: <b>${this.getTradeDuration(trade)}</b>\n`;
      message += `‚Ä¢ Final P&L: <b>${isProfit ? '+' : ''}$${trade.realizedPnL.toFixed(2)}</b>\n\n`;
      
      message += `üéØ <b>Take Profit Performance:</b>\n`;
      const { tp1, tp2, tp3 } = trade.takeProfits;
      message += `‚Ä¢ TP1: ${tp1.executed ? '‚úÖ' : '‚ùå'} ${tp1.executed ? `($${((tp1.price - trade.entryPrice) * tp1.quantity).toFixed(2)})` : ''}\n`;
      message += `‚Ä¢ TP2: ${tp2.executed ? '‚úÖ' : '‚ùå'} ${tp2.executed ? `($${((tp2.price - trade.entryPrice) * tp2.quantity).toFixed(2)})` : ''}\n`;
      message += `‚Ä¢ TP3: ${tp3.executed ? '‚úÖ' : '‚ùå'} ${tp3.executed ? `($${((tp3.price - trade.entryPrice) * tp3.quantity).toFixed(2)})` : ''}\n\n`;
      
      message += `üìà <b>Performance:</b>\n`;
      const returnPercent = (trade.realizedPnL / (trade.entryPrice * trade.quantity)) * 100;
      message += `‚Ä¢ Return: <b>${returnPercent.toFixed(2)}%</b>\n`;
      message += `‚Ä¢ Risk/Reward: <b>1:${Math.abs(trade.realizedPnL / trade.riskAmount).toFixed(2)}</b>\n`;
      
      message += `\n‚è∞ <i>${new Date().toLocaleString()}</i>`;
      
      await this.sendMessage(message, { parse_mode: 'HTML' });
      
      logger.info(`üì® Trade completion summary sent for ${trade.symbol}: $${trade.realizedPnL.toFixed(2)}`);
    } catch (error) {
      logger.error('‚ùå Error sending trade completion summary:', error.message);
    }
  }

  /**
   * ‚è±Ô∏è Calculate trade duration
   */
  getTradeDuration(trade) {
    const duration = Date.now() - trade.timestamp;
    const hours = Math.floor(duration / (1000 * 60 * 60));
    const minutes = Math.floor((duration % (1000 * 60 * 60)) / (1000 * 60));
    
    if (hours > 0) {
      return `${hours}h ${minutes}m`;
    } else {
      return `${minutes}m`;
    }
  }

  /**
   * üì® Generic send message with rate limiting
   */
  async sendMessage(text, options = {}) {
    if (!this.bot) {
      logger.debug('‚ö†Ô∏è No bot instance available');
      return;
    }
    
    if (!config.telegram.chatId) {
      logger.debug('‚ö†Ô∏è No chat ID configured');
      return;
    }

    try {
      // Rate limiting
      const now = Date.now();
      if (now - this.lastMessageTime < this.minMessageInterval) {
        await new Promise(resolve => setTimeout(resolve, this.minMessageInterval));
      }
      
      logger.debug(`üì® Sending to chat ${config.telegram.chatId}: ${text.substring(0, 50)}...`);
      
      await this.bot.telegram.sendMessage(config.telegram.chatId, text, options);
      this.lastMessageTime = Date.now();
      
      logger.debug('‚úÖ Message sent successfully');
      
    } catch (error) {
      if (error.code === 429) {
        // Rate limited - wait and retry
        const retryAfter = error.parameters?.retry_after || 30;
        logger.warn(`Rate limited, waiting ${retryAfter}s`);
        await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
        await this.sendMessage(text, options);
      } else {
        logger.error('‚ùå Error sending message:', error.message);
        throw error;
      }
    }
  }

  /**
   * üìä Get bot status
   */
  async getBotStatus() {
    const status = `ü§ñ <b>ProTradeAI Bot Status</b>\n\n`;
    
    let message = status;
    message += `üîã <b>Status:</b> ${this.initialized ? 'üü¢ Online' : 'üî¥ Offline'}\n`;
    message += `üíº <b>Mode:</b> ${config.tradeMode.toUpperCase()}\n`;
    message += `üéØ <b>Target:</b> $${config.profitTargets.daily}/day\n`;
    message += `‚öñÔ∏è <b>Risk:</b> ${config.capital.riskPerTrade}% per trade\n`;
    message += `ü™ô <b>Coins:</b> ${config.coins.maxCoins} selected\n`;
    message += `ü§ñ <b>AI:</b> GPT-4 + Claude\n`;
    message += `üìä <b>Min Confidence:</b> ${config.ai.confidence.minimum}%\n\n`;
    
    message += `üìà <b>Settings:</b>\n`;
    message += `‚Ä¢ Signal Approval: ${config.telegram.signalApproval ? '‚úÖ' : '‚ùå'}\n`;
    message += `‚Ä¢ Notifications: ${config.telegram.enabled ? '‚úÖ' : '‚ùå'}\n`;
    message += `‚Ä¢ Auto Trading: ${config.tradeMode === 'live' ? '‚úÖ' : '‚ùå'}\n`;
    
    return message;
  }

  /**
   * üìä Get trading stats
   */
  async getTradingStats() {
    // This would fetch actual trading statistics
    // For now, return mock data
    const stats = `üìä <b>Trading Statistics</b>\n\n`;
    
    let message = stats;
    message += `üí∞ <b>Today:</b>\n`;
    message += `‚Ä¢ P&L: <b>+$42.50</b>\n`;
    message += `‚Ä¢ Win Rate: <b>78.5%</b>\n`;
    message += `‚Ä¢ Trades: <b>7</b> (5W/2L)\n\n`;
    
    message += `üìà <b>This Week:</b>\n`;
    message += `‚Ä¢ P&L: <b>+$315.80</b>\n`;
    message += `‚Ä¢ Win Rate: <b>75.2%</b>\n`;
    message += `‚Ä¢ Trades: <b>42</b> (31W/11L)\n\n`;
    
    message += `üèÜ <b>All Time:</b>\n`;
    message += `‚Ä¢ Total P&L: <b>+$1,247.30</b>\n`;
    message += `‚Ä¢ Win Rate: <b>76.8%</b>\n`;
    message += `‚Ä¢ Total Trades: <b>156</b>\n`;
    message += `‚Ä¢ Best Day: <b>+$87.20</b>\n`;
    
    return message;
  }

  /**
   * ‚öôÔ∏è Get settings info
   */
  getSettingsInfo() {
    let message = `‚öôÔ∏è <b>Bot Settings</b>\n\n`;
    
    message += `üí∞ <b>Capital Management:</b>\n`;
    message += `‚Ä¢ Total Capital: <b>$${config.capital.total}</b>\n`;
    message += `‚Ä¢ Risk per Trade: <b>${config.capital.riskPerTrade}%</b>\n`;
    message += `‚Ä¢ Max Positions: <b>${config.capital.maxConcurrentTrades}</b>\n`;
    message += `‚Ä¢ Max Trade Size: <b>$${config.capital.maxTradeAmount}</b>\n\n`;
    
    message += `üìä <b>AI Settings:</b>\n`;
    message += `‚Ä¢ Min Confidence: <b>${config.ai.confidence.minimum}%</b>\n`;
    message += `‚Ä¢ GPT Weight: <b>${config.ai.confidence.gptWeight}%</b>\n`;
    message += `‚Ä¢ Claude Weight: <b>${config.ai.confidence.claudeWeight}%</b>\n\n`;
    
    message += `ü™ô <b>Coin Selection:</b>\n`;
    message += `‚Ä¢ Max Coins: <b>${config.coins.maxCoins}</b>\n`;
    message += `‚Ä¢ Min Volume: <b>$${(config.coins.minVolume / 1000000).toFixed(1)}M</b>\n`;
    message += `‚Ä¢ Whitelist: <b>${config.coins.whitelist.length} coins</b>\n\n`;
    
    message += `üîî <b>Notifications:</b>\n`;
    message += `‚Ä¢ Signals: ${config.telegram.notifications.signals ? '‚úÖ' : '‚ùå'}\n`;
    message += `‚Ä¢ Trades: ${config.telegram.notifications.trades ? '‚úÖ' : '‚ùå'}\n`;
    message += `‚Ä¢ Daily Summary: ${config.telegram.notifications.dailySummary ? '‚úÖ' : '‚ùå'}\n`;
    message += `‚Ä¢ Errors: ${config.telegram.notifications.errors ? '‚úÖ' : '‚ùå'}\n`;
    
    return message;
  }

  /**
   * üßπ Cleanup resources
   */
  cleanup() {
    if (this.bot) {
      this.bot.stop();
      logger.info('üßπ Telegram bot stopped');
    }
    this.messageQueue = [];
    this.rateLimitQueue = [];
  }
}

module.exports = TelegramBot;