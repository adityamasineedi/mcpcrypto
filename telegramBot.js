const { Telegraf, Markup } = require('telegraf');
const config = require('./config');
const logger = require('./utils/logger');

class TelegramBot {
  constructor() {
    this.bot = null;
    this.initialized = false;
    this.messageQueue = [];
    this.rateLimitQueue = [];
    this.lastMessageTime = 0;
    this.minMessageInterval = 2000; // 2 seconds between messages
  }

  /**
   * üöÄ Initialize Telegram Bot
   */
  async init() {
    try {
      if (!config.telegram.enabled || !config.telegram.botToken) {
        logger.warn('‚ö†Ô∏è Telegram bot disabled or token missing');
        this.initialized = true; // Mark as initialized but inactive
        return;
      }

      this.bot = new Telegraf(config.telegram.botToken);
      
      // Set up bot commands
      this.setupCommands();
      
      // Test bot connection
      const botInfo = await this.bot.telegram.getMe();
      logger.info(`‚úÖ Telegram bot connected: @${botInfo.username}`);
      
      // Start bot
      if (!config.testMode) {
        this.bot.launch();
        logger.info('üöÄ Telegram bot launched');
      }
      
      this.initialized = true;
      
      // Send startup message
      await this.sendMessage('üöÄ ProTradeAI Bot is now online and ready to send signals!');
      
    } catch (error) {
      logger.error('‚ùå Telegram bot initialization failed:', error.message);
      this.initialized = true; // Continue without Telegram
    }
  }

  /**
   * ‚öôÔ∏è Setup bot commands
   */
  setupCommands() {
    if (!this.bot) return;

    // Start command
    this.bot.command('start', (ctx) => {
      ctx.reply(
        'ü§ñ Welcome to ProTradeAI Bot!\n\n' +
        'üìä I provide crypto trading signals with 75%+ win rate\n' +
        'üí∞ Target: $50+ daily profit\n' +
        'üéØ Features: AI analysis, technical indicators, risk management\n\n' +
        'Commands:\n' +
        '/status - Bot status\n' +
        '/stats - Trading statistics\n' +
        '/settings - Bot settings\n' +
        '/help - Show help'
      );
    });

    // Status command
    this.bot.command('status', async (ctx) => {
      const status = await this.getBotStatus();
      ctx.reply(status, { parse_mode: 'HTML' });
    });

    // Stats command
    this.bot.command('stats', async (ctx) => {
      const stats = await this.getTradingStats();
      ctx.reply(stats, { parse_mode: 'HTML' });
    });

    // Settings command
    this.bot.command('settings', (ctx) => {
      const settings = this.getSettingsInfo();
      ctx.reply(settings, { parse_mode: 'HTML' });
    });

    // Help command
    this.bot.command('help', (ctx) => {
      ctx.reply(
        'üìö <b>ProTradeAI Bot Help</b>\n\n' +
        'üîî <b>Notifications:</b>\n' +
        '‚Ä¢ Trading signals with entry/exit points\n' +
        '‚Ä¢ Trade execution confirmations\n' +
        '‚Ä¢ Daily P&L summaries\n' +
        '‚Ä¢ Error alerts\n\n' +
        'üìä <b>Signal Format:</b>\n' +
        '‚Ä¢ Coin symbol and direction (LONG/SHORT)\n' +
        '‚Ä¢ Confidence level (0-100%)\n' +
        '‚Ä¢ Entry price and targets\n' +
        '‚Ä¢ Risk level and position size\n' +
        '‚Ä¢ AI reasoning\n\n' +
        '‚öôÔ∏è <b>Commands:</b>\n' +
        '/start - Welcome message\n' +
        '/status - Current bot status\n' +
        '/stats - Trading performance\n' +
        '/settings - Configuration info\n' +
        '/help - This help message',
        { parse_mode: 'HTML' }
      );
    });

    // Error handling
    this.bot.catch((err, ctx) => {
      logger.error('Telegram bot error:', err);
    });
  }

  /**
   * üì® Send trading signal
   */
  async sendSignal(signal) {
    logger.debug(`üîç sendSignal called for ${signal.symbol}, initialized: ${this.initialized}, notifications.signals: ${config.telegram.notifications.signals}`);
    
    if (!this.initialized || !config.telegram.notifications.signals) {
      logger.debug(`‚ö†Ô∏è Skipping signal send - initialized: ${this.initialized}, notifications: ${config.telegram.notifications.signals}`);
      return;
    }

    try {
      const message = this.formatSignalMessage(signal);
      const keyboard = this.createSignalKeyboard(signal);
      
      logger.debug(`üì® Sending signal message for ${signal.symbol}...`);
      
      await this.sendMessage(message, { 
        parse_mode: 'HTML',
        reply_markup: keyboard
      });
      
      logger.info(`üì® Signal sent for ${signal.symbol}: ${signal.type}`);
    } catch (error) {
      logger.error('‚ùå Error sending signal:', error.message);
    }
  }

  /**
   * üéØ Format signal message
   */
  formatSignalMessage(signal) {
    const direction = signal.type === 'LONG' ? 'üü¢' : signal.type === 'SHORT' ? 'üî¥' : 'üü°';
    const risk = signal.risk === 'LOW' ? 'üü¢' : signal.risk === 'MEDIUM' ? 'üü°' : 'üî¥';
    const confidence = signal.finalConfidence;
    const confidenceEmoji = confidence >= 80 ? 'üî•' : confidence >= 70 ? '‚ö°' : confidence >= 60 ? '‚úÖ' : '‚ö†Ô∏è';

    let message = `${direction} <b>${signal.symbol} ${signal.type}</b> ${confidenceEmoji}\n\n`;
    
    // Signal details
    message += `üìä <b>Signal Details:</b>\n`;
    message += `‚Ä¢ Confidence: <b>${confidence}%</b>\n`;
    message += `‚Ä¢ Strength: <b>${signal.strength}</b>\n`;
    message += `‚Ä¢ Risk Level: ${risk} <b>${signal.risk}</b>\n`;
    
    // ‚úÖ ENHANCED: Specific hold duration
    const holdDuration = this.getHoldDuration(signal.timeHorizon, signal.strength, signal.context.regime);
    message += `‚Ä¢ Hold Duration: <b>${holdDuration}</b>\n`;
    message += `‚Ä¢ Strategy: <b>${this.getStrategyType(signal.context.regime, signal.timeHorizon)}</b>\n\n`;
    
    // Prices
    message += `üí∞ <b>Price Levels:</b>\n`;
    message += `‚Ä¢ Current: <b>$${signal.currentPrice.toFixed(4)}</b>\n`;
    message += `‚Ä¢ Entry: <b>$${signal.entryPrice.toFixed(4)}</b>\n`;
    message += `‚Ä¢ Stop Loss: <b>$${signal.stopLoss.toFixed(4)}</b>\n`;
    if (signal.takeProfit) {
      message += `‚Ä¢ Take Profit: <b>$${signal.takeProfit.toFixed(4)}</b>\n`;
    }
    message += '\n';
    
    // Position details
    message += `üìà <b>Position:</b>\n`;
    message += `‚Ä¢ Size: <b>$${signal.positionSize.toFixed(2)}</b>\n`;
    message += `‚Ä¢ Max Loss: <b>$${signal.maxLoss.toFixed(2)}</b>\n`;
    if (signal.maxGain) {
      message += `‚Ä¢ Max Gain: <b>$${signal.maxGain.toFixed(2)}</b>\n`;
    }
    if (signal.riskReward) {
      message += `‚Ä¢ Risk/Reward: <b>1:${signal.riskReward.toFixed(1)}</b>\n`;
    }
    message += '\n';

    // ‚úÖ NEW: Position Management
    message += `‚è∞ <b>Position Management:</b>\n`;
    const exitConditions = this.getExitConditions(signal);
    exitConditions.forEach(condition => {
      message += `‚Ä¢ ${condition}\n`;
    });
    message += '\n';
    
    // Market context
    message += `üåç <b>Market Context:</b>\n`;
    message += `‚Ä¢ Regime: <b>${signal.context.regime}</b>\n`;
    message += `‚Ä¢ Sentiment: <b>${signal.context.sentiment}</b>\n`;
    message += `‚Ä¢ Fear/Greed: <b>${signal.context.fearGreed}</b>\n\n`;
    
    // AI Analysis with all 3 models
    message += `ü§ñ <b>AI Analysis:</b>\n`;
    message += `‚Ä¢ GPT-4: <b>${signal.ai.sources.gpt.confidence}%</b> (${signal.ai.sources.gpt.recommendation})\n`;
    message += `‚Ä¢ Claude: <b>${signal.ai.sources.claude.confidence}%</b> (${signal.ai.sources.claude.recommendation})\n`;
    if (signal.ai.sources.gemini) {
      message += `‚Ä¢ Gemini: <b>${signal.ai.sources.gemini.confidence}%</b> (${signal.ai.sources.gemini.recommendation})\n`;
    }
    message += `‚Ä¢ Reasoning: <i>${signal.ai.reasoning}</i>\n\n`;
    
    // Technical analysis
    message += `üìä <b>Technical:</b>\n`;
    message += `‚Ä¢ Score: <b>${signal.technical.confidence}%</b>\n`;
    message += `‚Ä¢ Signals: <i>${signal.technical.reasoning}</i>\n\n`;
    
    message += `‚è∞ <i>${new Date(signal.timestamp).toLocaleString()}</i>`;
    
    return message;
  }

  /**
   * ‚úÖ NEW: Get specific hold duration
   */
  getHoldDuration(timeHorizon, strength, regime) {
    const durations = {
      SHORT: {
        WEAK: '15-30 min',
        MEDIUM: '30-60 min', 
        STRONG: '1-2 hours'
      },
      MEDIUM: {
        WEAK: '2-4 hours',
        MEDIUM: '4-8 hours',
        STRONG: '8-12 hours'
      },
      LONG: {
        WEAK: '12-24 hours',
        MEDIUM: '1-2 days',
        STRONG: '2-3 days'
      }
    };

    // Adjust for market regime
    let baseDuration = durations[timeHorizon]?.[strength] || '1-2 hours';
    
    if (regime === 'SIDEWAYS') {
      baseDuration = baseDuration.replace(/hours/g, 'hours (shorter in sideways market)');
    }
    
    return baseDuration;
  }

  /**
   * ‚úÖ NEW: Get strategy type
   */
  getStrategyType(regime, timeHorizon) {
    if (regime === 'BULL' && timeHorizon === 'SHORT') return 'Momentum Scalping';
    if (regime === 'BULL' && timeHorizon === 'MEDIUM') return 'Trend Following';
    if (regime === 'BULL' && timeHorizon === 'LONG') return 'Position Trading';
    if (regime === 'BEAR' && timeHorizon === 'SHORT') return 'Bounce Trading';
    if (regime === 'BEAR') return 'Reversal Strategy';
    if (regime === 'SIDEWAYS') return 'Range Trading';
    return 'Adaptive Strategy';
  }

  /**
   * ‚úÖ NEW: Get exit conditions
   */
  getExitConditions(signal) {
    const conditions = [];
    
    // Time-based exits
    const holdDuration = this.getHoldDuration(signal.timeHorizon, signal.strength, signal.context.regime);
    conditions.push(`‚è±Ô∏è Close after: <b>${holdDuration}</b>`);
    
    // Price-based exits
    conditions.push(`üéØ Take Profit: <b>$${signal.takeProfit?.toFixed(4) || 'Manual'}</b>`);
    conditions.push(`üõë Stop Loss: <b>$${signal.stopLoss.toFixed(4)}</b>`);
    
    // Condition-based exits
    if (signal.context.regime === 'SIDEWAYS') {
      conditions.push(`üìä Exit if: Range breakout confirmed`);
    } else if (signal.context.regime === 'BULL') {
      conditions.push(`üìà Trail stop: Move SL to breakeven at +50%`);
    } else if (signal.context.regime === 'BEAR') {
      conditions.push(`üìâ Quick exit: Close on volume spike reversal`);
    }
    
    // Technical exit signals
    if (signal.strength === 'STRONG') {
      conditions.push(`üîÑ Monitor: RSI divergence for early exit`);
    }
    
    return conditions;
  }

  /**
   * ‚å®Ô∏è Create signal keyboard
   */
  createSignalKeyboard(signal) {
    if (!config.telegram.signalApproval) return null;

    return Markup.inlineKeyboard([
      [
        Markup.button.callback('‚úÖ Execute', `execute_${signal.id}`),
        Markup.button.callback('‚ùå Reject', `reject_${signal.id}`)
      ],
      [
        Markup.button.callback('üìä Details', `details_${signal.id}`),
        Markup.button.callback('‚è∞ Delay', `delay_${signal.id}`)
      ]
    ]);
  }

  /**
   * üíº Send trade execution notification
   */
  async sendTradeExecution(trade) {
    if (!this.initialized || !config.telegram.notifications.trades) return;

    try {
      const direction = trade.side === 'LONG' ? 'üü¢' : 'üî¥';
      const status = trade.status === 'FILLED' ? '‚úÖ' : trade.status === 'FAILED' ? '‚ùå' : '‚è≥';
      
      let message = `${status} <b>Trade ${trade.status}</b> ${direction}\n\n`;
      
      message += `ü™ô <b>Symbol:</b> ${trade.symbol}\n`;
      message += `üìä <b>Side:</b> ${trade.side}\n`;
      message += `üí∞ <b>Size:</b> $${trade.amount.toFixed(2)}\n`;
      message += `üíµ <b>Price:</b> $${trade.price.toFixed(4)}\n`;
      
      if (trade.status === 'FILLED') {
        message += `üî• <b>Total:</b> $${(trade.amount * trade.price).toFixed(2)}\n`;
        if (trade.fee) {
          message += `üí∏ <b>Fee:</b> $${trade.fee.toFixed(2)}\n`;
        }
      }
      
      if (trade.error) {
        message += `‚ùå <b>Error:</b> ${trade.error}\n`;
      }
      
      message += `\n‚è∞ ${new Date(trade.timestamp).toLocaleString()}`;
      
      await this.sendMessage(message, { parse_mode: 'HTML' });
      
      logger.info(`üì® Trade notification sent: ${trade.symbol} ${trade.status}`);
    } catch (error) {
      logger.error('‚ùå Error sending trade notification:', error.message);
    }
  }

  /**
   * üìä Send daily summary
   */
  async sendDailySummary(summary) {
    if (!this.initialized || !config.telegram.notifications.dailySummary) return;

    try {
      const profitEmoji = summary.totalPnL >= 0 ? 'üíö' : '‚ù§Ô∏è';
      const winRateEmoji = summary.winRate >= 75 ? 'üî•' : summary.winRate >= 65 ? '‚úÖ' : '‚ö†Ô∏è';
      
      let message = `üìä <b>Daily Trading Summary</b> ${profitEmoji}\n\n`;
      
      // Performance
      message += `üí∞ <b>Performance:</b>\n`;
      message += `‚Ä¢ Total P&L: <b>${summary.totalPnL >= 0 ? '+' : ''}$${summary.totalPnL.toFixed(2)}</b>\n`;
      message += `‚Ä¢ Win Rate: ${winRateEmoji} <b>${summary.winRate.toFixed(1)}%</b>\n`;
      message += `‚Ä¢ Trades: <b>${summary.totalTrades}</b> (${summary.winningTrades}W/${summary.losingTrades}L)\n`;
      message += `‚Ä¢ Best Trade: <b>+$${summary.bestTrade.toFixed(2)}</b>\n`;
      message += `‚Ä¢ Worst Trade: <b>-$${Math.abs(summary.worstTrade).toFixed(2)}</b>\n\n`;
      
      // Activity
      message += `üìà <b>Trading Activity:</b>\n`;
      message += `‚Ä¢ Signals Generated: <b>${summary.signalsGenerated}</b>\n`;
      message += `‚Ä¢ Signals Executed: <b>${summary.signalsExecuted}</b>\n`;
      message += `‚Ä¢ Avg Confidence: <b>${summary.avgConfidence.toFixed(1)}%</b>\n`;
      message += `‚Ä¢ Most Traded: <b>${summary.mostTradedCoin}</b>\n\n`;
      
      // Account
      message += `üíº <b>Account:</b>\n`;
      message += `‚Ä¢ Balance: <b>$${summary.currentBalance.toFixed(2)}</b>\n`;
      message += `‚Ä¢ Daily Change: <b>${summary.dailyChange >= 0 ? '+' : ''}${summary.dailyChange.toFixed(2)}%</b>\n`;
      message += `‚Ä¢ Open Positions: <b>${summary.openPositions}</b>\n\n`;
      
      // Goals
      message += `üéØ <b>Goals Progress:</b>\n`;
      message += `‚Ä¢ Daily Target: <b>$${config.profitTargets.daily}</b>\n`;
      message += `‚Ä¢ Progress: <b>${((summary.totalPnL / config.profitTargets.daily) * 100).toFixed(1)}%</b>\n`;
      message += `‚Ä¢ Win Rate Target: <b>${config.profitTargets.winRateTarget}%</b>\n\n`;
      
      message += `üìÖ <i>${new Date().toLocaleDateString()}</i>`;
      
      await this.sendMessage(message, { parse_mode: 'HTML' });
      
      logger.info('üì® Daily summary sent');
    } catch (error) {
      logger.error('‚ùå Error sending daily summary:', error.message);
    }
  }

  /**
   * ‚ö†Ô∏è Send error alert
   */
  async sendError(error, context = '') {
    if (!this.initialized || !config.telegram.notifications.errors) return;

    try {
      let message = `üö® <b>Error Alert</b>\n\n`;
      
      if (context) {
        message += `üìç <b>Context:</b> ${context}\n`;
      }
      
      message += `‚ùå <b>Error:</b> ${error.message || error}\n`;
      message += `‚è∞ <b>Time:</b> ${new Date().toLocaleString()}\n\n`;
      
      message += `üîß Please check the logs for more details.`;
      
      await this.sendMessage(message, { parse_mode: 'HTML' });
      
      logger.info('üì® Error alert sent');
    } catch (err) {
      logger.error('‚ùå Error sending error alert:', err.message);
    }
  }

  /**
   * üì® Generic send message with rate limiting
   */
  async sendMessage(text, options = {}) {
    if (!this.bot) {
      logger.debug('‚ö†Ô∏è No bot instance available');
      return;
    }
    
    if (!config.telegram.chatId) {
      logger.debug('‚ö†Ô∏è No chat ID configured');
      return;
    }

    try {
      // Rate limiting
      const now = Date.now();
      if (now - this.lastMessageTime < this.minMessageInterval) {
        await new Promise(resolve => setTimeout(resolve, this.minMessageInterval));
      }
      
      logger.debug(`üì® Sending to chat ${config.telegram.chatId}: ${text.substring(0, 50)}...`);
      
      await this.bot.telegram.sendMessage(config.telegram.chatId, text, options);
      this.lastMessageTime = Date.now();
      
      logger.debug('‚úÖ Message sent successfully');
      
    } catch (error) {
      if (error.code === 429) {
        // Rate limited - wait and retry
        const retryAfter = error.parameters?.retry_after || 30;
        logger.warn(`Rate limited, waiting ${retryAfter}s`);
        await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
        await this.sendMessage(text, options);
      } else {
        logger.error('‚ùå Error sending message:', error.message);
        throw error;
      }
    }
  }

  /**
   * üìä Get bot status
   */
  async getBotStatus() {
    const status = `ü§ñ <b>ProTradeAI Bot Status</b>\n\n`;
    
    let message = status;
    message += `üîã <b>Status:</b> ${this.initialized ? 'üü¢ Online' : 'üî¥ Offline'}\n`;
    message += `üíº <b>Mode:</b> ${config.tradeMode.toUpperCase()}\n`;
    message += `üéØ <b>Target:</b> $${config.profitTargets.daily}/day\n`;
    message += `‚öñÔ∏è <b>Risk:</b> ${config.capital.riskPerTrade}% per trade\n`;
    message += `ü™ô <b>Coins:</b> ${config.coins.maxCoins} selected\n`;
    message += `ü§ñ <b>AI:</b> GPT-4 + Claude\n`;
    message += `üìä <b>Min Confidence:</b> ${config.ai.confidence.minimum}%\n\n`;
    
    message += `üìà <b>Settings:</b>\n`;
    message += `‚Ä¢ Signal Approval: ${config.telegram.signalApproval ? '‚úÖ' : '‚ùå'}\n`;
    message += `‚Ä¢ Notifications: ${config.telegram.enabled ? '‚úÖ' : '‚ùå'}\n`;
    message += `‚Ä¢ Auto Trading: ${config.tradeMode === 'live' ? '‚úÖ' : '‚ùå'}\n`;
    
    return message;
  }

  /**
   * üìä Get trading stats
   */
  async getTradingStats() {
    // This would fetch actual trading statistics
    // For now, return mock data
    const stats = `üìä <b>Trading Statistics</b>\n\n`;
    
    let message = stats;
    message += `üí∞ <b>Today:</b>\n`;
    message += `‚Ä¢ P&L: <b>+$42.50</b>\n`;
    message += `‚Ä¢ Win Rate: <b>78.5%</b>\n`;
    message += `‚Ä¢ Trades: <b>7</b> (5W/2L)\n\n`;
    
    message += `üìà <b>This Week:</b>\n`;
    message += `‚Ä¢ P&L: <b>+$315.80</b>\n`;
    message += `‚Ä¢ Win Rate: <b>75.2%</b>\n`;
    message += `‚Ä¢ Trades: <b>42</b> (31W/11L)\n\n`;
    
    message += `üèÜ <b>All Time:</b>\n`;
    message += `‚Ä¢ Total P&L: <b>+$1,247.30</b>\n`;
    message += `‚Ä¢ Win Rate: <b>76.8%</b>\n`;
    message += `‚Ä¢ Total Trades: <b>156</b>\n`;
    message += `‚Ä¢ Best Day: <b>+$87.20</b>\n`;
    
    return message;
  }

  /**
   * ‚öôÔ∏è Get settings info
   */
  getSettingsInfo() {
    let message = `‚öôÔ∏è <b>Bot Settings</b>\n\n`;
    
    message += `üí∞ <b>Capital Management:</b>\n`;
    message += `‚Ä¢ Total Capital: <b>$${config.capital.total}</b>\n`;
    message += `‚Ä¢ Risk per Trade: <b>${config.capital.riskPerTrade}%</b>\n`;
    message += `‚Ä¢ Max Positions: <b>${config.capital.maxConcurrentTrades}</b>\n`;
    message += `‚Ä¢ Max Trade Size: <b>$${config.capital.maxTradeAmount}</b>\n\n`;
    
    message += `üìä <b>AI Settings:</b>\n`;
    message += `‚Ä¢ Min Confidence: <b>${config.ai.confidence.minimum}%</b>\n`;
    message += `‚Ä¢ GPT Weight: <b>${config.ai.confidence.gptWeight}%</b>\n`;
    message += `‚Ä¢ Claude Weight: <b>${config.ai.confidence.claudeWeight}%</b>\n\n`;
    
    message += `ü™ô <b>Coin Selection:</b>\n`;
    message += `‚Ä¢ Max Coins: <b>${config.coins.maxCoins}</b>\n`;
    message += `‚Ä¢ Min Volume: <b>$${(config.coins.minVolume / 1000000).toFixed(1)}M</b>\n`;
    message += `‚Ä¢ Whitelist: <b>${config.coins.whitelist.length} coins</b>\n\n`;
    
    message += `üîî <b>Notifications:</b>\n`;
    message += `‚Ä¢ Signals: ${config.telegram.notifications.signals ? '‚úÖ' : '‚ùå'}\n`;
    message += `‚Ä¢ Trades: ${config.telegram.notifications.trades ? '‚úÖ' : '‚ùå'}\n`;
    message += `‚Ä¢ Daily Summary: ${config.telegram.notifications.dailySummary ? '‚úÖ' : '‚ùå'}\n`;
    message += `‚Ä¢ Errors: ${config.telegram.notifications.errors ? '‚úÖ' : '‚ùå'}\n`;
    
    return message;
  }

  /**
   * üßπ Cleanup resources
   */
  cleanup() {
    if (this.bot) {
      this.bot.stop();
      logger.info('üßπ Telegram bot stopped');
    }
    this.messageQueue = [];
    this.rateLimitQueue = [];
  }
}

module.exports = TelegramBot;